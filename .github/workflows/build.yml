name: Build Library

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]
  release:
    types: [ published ]
  workflow_dispatch:

jobs:
  build-ubuntu:
    name: Build on Ubuntu (${{ matrix.link-type }} OpenSSL)
    runs-on: ubuntu-22.04
    strategy:
      fail-fast: false
      matrix:
        link-type: [Static, Runtime]
    
    steps:
    - uses: actions/checkout@v4

    - name: Install OpenSSL
      run: |
        sudo apt-get update
        sudo apt-get install -y libssl-dev

    - name: Configure CMake
      run: |
        mkdir -p build
        cd build
        if [ "${{ matrix.link-type }}" == "Runtime" ]; then
          cmake -DOPENSSL_RUNTIME_LINK=ON ..
        else
          cmake ..
        fi

    - name: Build
      run: |
        cd build
        make VERBOSE=1

    - name: Run tests
      run: |
        cd build
        ctest --output-on-failure

    - name: Create package
      run: |
        mkdir -p package
        ARTIFACT_NAME="echeck-ubuntu-$(date +%Y%m%d)-${{ matrix.link-type == 'Runtime' && 'runtime' || 'static' }}"
        mkdir -p "package/$ARTIFACT_NAME/bin"
        mkdir -p "package/$ARTIFACT_NAME/lib"
        mkdir -p "package/$ARTIFACT_NAME/include/echeck"
        
        # Copy files
        cp build/echeck "package/$ARTIFACT_NAME/bin/"
        cp build/libecheck.a "package/$ARTIFACT_NAME/lib/"
        cp include/echeck.h "package/$ARTIFACT_NAME/include/echeck/"
        cp README.md LICENSE* "package/$ARTIFACT_NAME/" 2>/dev/null || true
        
        # Create tarball
        cd package
        tar -czvf "$ARTIFACT_NAME.tar.gz" "$ARTIFACT_NAME"

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: echeck-ubuntu-${{ matrix.link-type == 'Runtime' && 'runtime' || 'static' }}
        path: package/*.tar.gz

  build-macos:
    name: Build on macOS (${{ matrix.link-type }} OpenSSL)
    runs-on: macos-latest
    strategy:
      fail-fast: false
      matrix:
        link-type: [Static, Runtime]
    
    steps:
    - uses: actions/checkout@v4

    - name: Install OpenSSL
      run: |
        brew install openssl@3 || true
        echo "OPENSSL_ROOT_DIR=$(brew --prefix openssl@3)" >> $GITHUB_ENV
        echo "OPENSSL_INCLUDE_DIR=$(brew --prefix openssl@3)/include" >> $GITHUB_ENV

    - name: Configure CMake
      run: |
        mkdir -p build
        cd build
        if [ "${{ matrix.link-type }}" == "Runtime" ]; then
          cmake -DOPENSSL_RUNTIME_LINK=ON -DCMAKE_C_FLAGS="-I$OPENSSL_INCLUDE_DIR" \
            -DOPENSSL_ROOT_DIR=$OPENSSL_ROOT_DIR -DOPENSSL_INCLUDE_DIR=$OPENSSL_INCLUDE_DIR ..
        else
          cmake -DCMAKE_C_FLAGS="-I$OPENSSL_INCLUDE_DIR" \
            -DOPENSSL_ROOT_DIR=$OPENSSL_ROOT_DIR -DOPENSSL_INCLUDE_DIR=$OPENSSL_INCLUDE_DIR ..
        fi

    - name: Build
      run: |
        cd build
        make VERBOSE=1

    - name: Run tests
      run: |
        cd build
        # Set DYLD_LIBRARY_PATH for macOS runtime tests
        export DYLD_LIBRARY_PATH=/opt/homebrew/opt/openssl@3/lib:$DYLD_LIBRARY_PATH
        ctest --output-on-failure

    - name: Create package
      run: |
        mkdir -p package
        ARTIFACT_NAME="echeck-macos-$(date +%Y%m%d)-${{ matrix.link-type == 'Runtime' && 'runtime' || 'static' }}"
        mkdir -p "package/$ARTIFACT_NAME/bin"
        mkdir -p "package/$ARTIFACT_NAME/lib"
        mkdir -p "package/$ARTIFACT_NAME/include/echeck"
        
        # Copy files
        cp build/echeck "package/$ARTIFACT_NAME/bin/"
        cp build/libecheck.a "package/$ARTIFACT_NAME/lib/"
        cp include/echeck.h "package/$ARTIFACT_NAME/include/echeck/"
        cp README.md LICENSE* "package/$ARTIFACT_NAME/" 2>/dev/null || true
        
        # Create tarball
        cd package
        tar -czvf "$ARTIFACT_NAME.tar.gz" "$ARTIFACT_NAME"

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: echeck-macos-${{ matrix.link-type == 'Runtime' && 'runtime' || 'static' }}
        path: package/*.tar.gz

  build-windows:
    name: Build on Windows (${{ matrix.link-type }} OpenSSL)
    runs-on: windows-latest
    strategy:
      fail-fast: false
      matrix:
        link-type: [Static, Runtime]
    
    steps:
    - uses: actions/checkout@v4

    - name: Install OpenSSL
      shell: pwsh
      run: |
        choco install openssl
        echo "OPENSSL_ROOT_DIR=C:/Program Files/OpenSSL-Win64" >> $env:GITHUB_ENV
        echo "OPENSSL_LIBRARIES=C:/Program Files/OpenSSL-Win64/lib" >> $env:GITHUB_ENV
        echo "OPENSSL_INCLUDE_DIR=C:/Program Files/OpenSSL-Win64/include" >> $env:GITHUB_ENV

    - name: Configure CMake
      shell: pwsh
      run: |
        New-Item -ItemType Directory -Force -Path build
        cd build
        if ("${{ matrix.link-type }}" -eq "Runtime") {
          cmake -G "Visual Studio 17 2022" -A x64 -DOPENSSL_RUNTIME_LINK=ON `
            -DOPENSSL_ROOT_DIR="$env:OPENSSL_ROOT_DIR" `
            -DOPENSSL_LIBRARIES="$env:OPENSSL_LIBRARIES" `
            -DOPENSSL_INCLUDE_DIR="$env:OPENSSL_INCLUDE_DIR" ..
        } else {
          cmake -G "Visual Studio 17 2022" -A x64 `
            -DOPENSSL_ROOT_DIR="$env:OPENSSL_ROOT_DIR" `
            -DOPENSSL_LIBRARIES="$env:OPENSSL_LIBRARIES" `
            -DOPENSSL_INCLUDE_DIR="$env:OPENSSL_INCLUDE_DIR" ..
        }

    - name: Build
      shell: pwsh
      run: |
        cd build
        cmake --build . --config Release

    - name: Run tests
      shell: pwsh
      run: |
        cd build
        ctest -C Release --output-on-failure

    - name: Create package
      shell: pwsh
      run: |
        $linkType = "${{ matrix.link-type }}"
        $linkTypeLower = if ($linkType -eq "Runtime") { "runtime" } else { "static" }
        
        # Create artifact directory
        $ARTIFACT_NAME = "echeck-windows-$(Get-Date -Format 'yyyyMMdd')-$linkTypeLower"
        New-Item -ItemType Directory -Force -Path "package/$ARTIFACT_NAME/bin"
        New-Item -ItemType Directory -Force -Path "package/$ARTIFACT_NAME/lib"
        New-Item -ItemType Directory -Force -Path "package/$ARTIFACT_NAME/include/echeck"
        
        # Copy files
        Copy-Item "build/Release/echeck.exe" -Destination "package/$ARTIFACT_NAME/bin/"
        Copy-Item "build/Release/echeck.lib" -Destination "package/$ARTIFACT_NAME/lib/"
        Copy-Item "include/echeck.h" -Destination "package/$ARTIFACT_NAME/include/echeck/"
        Copy-Item "README.md" -Destination "package/$ARTIFACT_NAME/" -ErrorAction SilentlyContinue
        Copy-Item "LICENSE*" -Destination "package/$ARTIFACT_NAME/" -ErrorAction SilentlyContinue
        
        # Create zip archive
        Compress-Archive -Path "package/$ARTIFACT_NAME" -DestinationPath "package/$ARTIFACT_NAME.zip"

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: echeck-windows-${{ matrix.link-type == 'Runtime' && 'runtime' || 'static' }}
        path: package/*.zip

  release-artifacts:
    name: Upload artifacts to release
    runs-on: ubuntu-latest
    if: github.event_name == 'release'
    needs: [build-ubuntu, build-macos, build-windows]
    
    steps:
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts
        
    - name: Upload artifacts to release
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const path = require('path');
          const { repo } = context;
          
          // Get the release ID
          const release = context.payload.release;
          
          // Iterate through all downloaded artifacts
          const artifactsDir = 'artifacts';
          const artifacts = fs.readdirSync(artifactsDir);
          
          for (const artifact of artifacts) {
            const artifactDir = path.join(artifactsDir, artifact);
            const files = fs.readdirSync(artifactDir);
            
            for (const file of files) {
              const filePath = path.join(artifactDir, file);
              console.log(`Uploading ${filePath} to release ${release.id}`);
              
              const fileContent = fs.readFileSync(filePath);
              
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.id,
                name: file,
                data: fileContent
              });
            }
          }