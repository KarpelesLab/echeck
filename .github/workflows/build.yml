name: Build Library

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]
  release:
    types: [ published ]
  workflow_dispatch:

jobs:
  build-ubuntu:
    name: Build on Ubuntu (${{ matrix.link-type }} OpenSSL)
    runs-on: ubuntu-22.04
    strategy:
      fail-fast: false
      matrix:
        link-type: [Static, Runtime]
    
    steps:
    - uses: actions/checkout@v4

    - name: Install OpenSSL
      run: |
        sudo apt-get update
        sudo apt-get install -y libssl-dev

    - name: Configure CMake
      run: |
        mkdir -p build
        cd build
        if [ "${{ matrix.link-type }}" == "Runtime" ]; then
          cmake -DOPENSSL_RUNTIME_LINK=ON ..
        else
          cmake ..
        fi

    - name: Build
      run: |
        cd build
        make VERBOSE=1

    - name: Run tests
      run: |
        cd build
        ctest --output-on-failure

    - name: Create package
      run: |
        mkdir -p package
        ARTIFACT_NAME="echeck-ubuntu-$(date +%Y%m%d)-${{ matrix.link-type == 'Runtime' && 'runtime' || 'static' }}"
        mkdir -p "package/$ARTIFACT_NAME/bin"
        mkdir -p "package/$ARTIFACT_NAME/lib"
        mkdir -p "package/$ARTIFACT_NAME/include/echeck"
        
        # Copy files
        cp build/echeck "package/$ARTIFACT_NAME/bin/"
        cp build/libecheck.a "package/$ARTIFACT_NAME/lib/"
        cp include/echeck.h "package/$ARTIFACT_NAME/include/echeck/"
        cp README.md LICENSE* "package/$ARTIFACT_NAME/" 2>/dev/null || true
        
        # Create tarball
        cd package
        tar -czvf "$ARTIFACT_NAME.tar.gz" "$ARTIFACT_NAME"

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: echeck-ubuntu-${{ matrix.link-type == 'Runtime' && 'runtime' || 'static' }}
        path: package/*.tar.gz

  build-macos:
    name: Build on macOS (${{ matrix.link-type }} OpenSSL)
    runs-on: macos-latest
    strategy:
      fail-fast: false
      matrix:
        link-type: [Static, Runtime]
    
    steps:
    - uses: actions/checkout@v4

    - name: Install OpenSSL
      run: |
        brew install openssl@3 || true
        echo "OPENSSL_ROOT_DIR=$(brew --prefix openssl@3)" >> $GITHUB_ENV
        echo "OPENSSL_INCLUDE_DIR=$(brew --prefix openssl@3)/include" >> $GITHUB_ENV

    - name: Configure CMake
      run: |
        mkdir -p build
        cd build
        if [ "${{ matrix.link-type }}" == "Runtime" ]; then
          cmake -DOPENSSL_RUNTIME_LINK=ON -DCMAKE_C_FLAGS="-I$OPENSSL_INCLUDE_DIR" \
            -DOPENSSL_ROOT_DIR=$OPENSSL_ROOT_DIR -DOPENSSL_INCLUDE_DIR=$OPENSSL_INCLUDE_DIR ..
        else
          cmake -DCMAKE_C_FLAGS="-I$OPENSSL_INCLUDE_DIR" \
            -DOPENSSL_ROOT_DIR=$OPENSSL_ROOT_DIR -DOPENSSL_INCLUDE_DIR=$OPENSSL_INCLUDE_DIR ..
        fi

    - name: Build
      run: |
        cd build
        make VERBOSE=1

    - name: Run tests
      run: |
        cd build
        # Set DYLD_LIBRARY_PATH for macOS runtime tests
        export DYLD_LIBRARY_PATH=/opt/homebrew/opt/openssl@3/lib:$DYLD_LIBRARY_PATH
        ctest --output-on-failure

    - name: Create package
      run: |
        mkdir -p package
        ARTIFACT_NAME="echeck-macos-$(date +%Y%m%d)-${{ matrix.link-type == 'Runtime' && 'runtime' || 'static' }}"
        mkdir -p "package/$ARTIFACT_NAME/bin"
        mkdir -p "package/$ARTIFACT_NAME/lib"
        mkdir -p "package/$ARTIFACT_NAME/include/echeck"
        
        # Copy files
        cp build/echeck "package/$ARTIFACT_NAME/bin/"
        cp build/libecheck.a "package/$ARTIFACT_NAME/lib/"
        cp include/echeck.h "package/$ARTIFACT_NAME/include/echeck/"
        cp README.md LICENSE* "package/$ARTIFACT_NAME/" 2>/dev/null || true
        
        # Create tarball
        cd package
        tar -czvf "$ARTIFACT_NAME.tar.gz" "$ARTIFACT_NAME"

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: echeck-macos-${{ matrix.link-type == 'Runtime' && 'runtime' || 'static' }}
        path: package/*.tar.gz

  build-windows:
    name: Build on Windows x64 (${{ matrix.link-type }} OpenSSL)
    runs-on: windows-latest
    strategy:
      fail-fast: false
      matrix:
        link-type: [Static, Runtime]
    
    steps:
    - uses: actions/checkout@v4

    - name: Install OpenSSL
      shell: pwsh
      run: |
        choco install openssl

        # Check both possible installation paths
        if (Test-Path "C:/Program Files/OpenSSL") {
          $opensslPath = "C:/Program Files/OpenSSL"
        } elseif (Test-Path "C:/Program Files/OpenSSL-Win64") {
          $opensslPath = "C:/Program Files/OpenSSL-Win64"
        } else {
          Write-Host "ERROR: Could not find OpenSSL installation directory!"
          exit 1
        }

        echo "OPENSSL_ROOT_DIR=$opensslPath" >> $env:GITHUB_ENV
        echo "OPENSSL_INCLUDE_DIR=$opensslPath/include" >> $env:GITHUB_ENV

        Write-Host "Using OpenSSL installation at: $opensslPath"

        # Verify paths to ensure they exist
        Get-ChildItem -Path "$opensslPath" -Recurse -Include *.lib | Select-Object -First 10 | ForEach-Object { $_.FullName }

    - name: Configure CMake
      shell: pwsh
      run: |
        New-Item -ItemType Directory -Force -Path build
        cd build

        # Use simpler configuration with fewer variables
        # Let CMake's FindOpenSSL module do most of the work
        if ("${{ matrix.link-type }}" -eq "Runtime") {
          cmake -G "Visual Studio 17 2022" -A x64 -DOPENSSL_RUNTIME_LINK=ON `
            -DOPENSSL_ROOT_DIR="$env:OPENSSL_ROOT_DIR" `
            -DOPENSSL_INCLUDE_DIR="$env:OPENSSL_INCLUDE_DIR" ..
        } else {
          cmake -G "Visual Studio 17 2022" -A x64 `
            -DOPENSSL_ROOT_DIR="$env:OPENSSL_ROOT_DIR" `
            -DOPENSSL_INCLUDE_DIR="$env:OPENSSL_INCLUDE_DIR" ..
        }

    - name: Build
      shell: pwsh
      run: |
        cd build
        cmake --build . --config Release

    - name: Run tests
      shell: pwsh
      run: |
        cd build
        ctest -C Release --output-on-failure

    - name: Create package
      shell: pwsh
      run: |
        $linkType = "${{ matrix.link-type }}"
        $linkTypeLower = if ($linkType -eq "Runtime") { "runtime" } else { "static" }
        
        # Create artifact directory
        $ARTIFACT_NAME = "echeck-windows-x64-$(Get-Date -Format 'yyyyMMdd')-$linkTypeLower"
        New-Item -ItemType Directory -Force -Path "package/$ARTIFACT_NAME/bin"
        New-Item -ItemType Directory -Force -Path "package/$ARTIFACT_NAME/lib"
        New-Item -ItemType Directory -Force -Path "package/$ARTIFACT_NAME/include/echeck"
        
        # Copy files
        Copy-Item "build/Release/echeck.exe" -Destination "package/$ARTIFACT_NAME/bin/"
        Copy-Item "build/Release/echeck.lib" -Destination "package/$ARTIFACT_NAME/lib/"
        Copy-Item "include/echeck.h" -Destination "package/$ARTIFACT_NAME/include/echeck/"
        Copy-Item "README.md" -Destination "package/$ARTIFACT_NAME/" -ErrorAction SilentlyContinue
        Copy-Item "LICENSE*" -Destination "package/$ARTIFACT_NAME/" -ErrorAction SilentlyContinue
        
        # Create zip archive
        Compress-Archive -Path "package/$ARTIFACT_NAME" -DestinationPath "package/$ARTIFACT_NAME.zip"

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: echeck-windows-x64-${{ matrix.link-type == 'Runtime' && 'runtime' || 'static' }}
        path: package/*.zip
        
  build-windows-arm64:
    name: Build on Windows ARM64 (${{ matrix.link-type }} OpenSSL)
    # Use dedicated Windows ARM64 runner
    runs-on: windows-11-arm
    strategy:
      fail-fast: false
      matrix:
        link-type: [Static, Runtime]

    steps:
    - uses: actions/checkout@v4

    - name: Install OpenSSL
      shell: pwsh
      run: |
        # For now, we still use x64 headers (compatible) but will use runtime loading
        # In the future, we'll use custom-built ARM64 OpenSSL from our other workflow

        # Check both possible installation paths
        if (Test-Path "C:/Program Files/OpenSSL") {
          $opensslPath = "C:/Program Files/OpenSSL"
        } elseif (Test-Path "C:/Program Files/OpenSSL-Win64") {
          $opensslPath = "C:/Program Files/OpenSSL-Win64"
        } else {
          Write-Host "ERROR: Could not find OpenSSL installation directory!"
          exit 1
        }

        echo "OPENSSL_ROOT_DIR=$opensslPath" >> $env:GITHUB_ENV
        echo "OPENSSL_INCLUDE_DIR=$opensslPath/include" >> $env:GITHUB_ENV

        Write-Host "Using OpenSSL installation at: $opensslPath"

        # Verify paths to ensure they exist
        Get-ChildItem -Path "$opensslPath" -Recurse -Include *.dll, *.lib | Select-Object -First 10 | ForEach-Object { $_.FullName }

        # TODO: Once we have our ARM64 OpenSSL build, we can use:
        # - Download the OpenSSL ARM64 artifact
        # - Set OPENSSL_ROOT_DIR to the extracted location
        # - Set OPENSSL_CRYPTO_LIBRARY and OPENSSL_SSL_LIBRARY for static builds

    - name: Configure CMake
      shell: pwsh
      run: |
        New-Item -ItemType Directory -Force -Path build
        cd build
        # For now, always use runtime mode for ARM64
        # TODO: When we have ARM64 libraries, use matrix.link-type to decide
        cmake -G "Visual Studio 17 2022" -A ARM64 -DOPENSSL_RUNTIME_LINK=ON `
          -DOPENSSL_ROOT_DIR="$env:OPENSSL_ROOT_DIR" `
          -DOPENSSL_INCLUDE_DIR="$env:OPENSSL_INCLUDE_DIR" ..

    - name: Build
      shell: pwsh
      run: |
        cd build
        cmake --build . --config Release

    - name: Run tests
      shell: pwsh
      run: |
        cd build

        # For ARM64 runtime builds, add diagnostic tracing to see which DLLs are loaded
        if ("${{ matrix.link-type }}" -eq "Runtime") {
          # Copy the Release binaries to a test directory
          New-Item -ItemType Directory -Force -Path test
          Copy-Item "Release/echeck.exe" -Destination "test/"

          # List available OpenSSL DLLs
          Write-Host "Available OpenSSL DLLs:"
          Get-ChildItem -Path "C:/Program Files" -Recurse -Include *ssl*.dll, *crypto*.dll -ErrorAction SilentlyContinue | Select-Object -First 20 | ForEach-Object { $_.FullName }

          # Run the test program - output will show which DLLs are loaded at runtime
          Write-Host "Running test program manually to see DLL loading:"
          cd test
          try {
            ./echeck.exe --version
          } catch {
            Write-Host "Error running test program: $_"
          }
          cd ..
        }

        # Run the actual tests
        ctest -C Release --output-on-failure

    - name: Create package
      shell: pwsh
      run: |
        $linkType = "${{ matrix.link-type }}"
        $linkTypeLower = if ($linkType -eq "Runtime") { "runtime" } else { "static" }

        # Create artifact directory
        $ARTIFACT_NAME = "echeck-windows-arm64-$(Get-Date -Format 'yyyyMMdd')-$linkTypeLower"
        New-Item -ItemType Directory -Force -Path "package/$ARTIFACT_NAME/bin"
        New-Item -ItemType Directory -Force -Path "package/$ARTIFACT_NAME/lib"
        New-Item -ItemType Directory -Force -Path "package/$ARTIFACT_NAME/include/echeck"

        # Copy files
        Copy-Item "build/Release/echeck.exe" -Destination "package/$ARTIFACT_NAME/bin/"
        Copy-Item "build/Release/echeck.lib" -Destination "package/$ARTIFACT_NAME/lib/"
        Copy-Item "include/echeck.h" -Destination "package/$ARTIFACT_NAME/include/echeck/"
        Copy-Item "README.md" -Destination "package/$ARTIFACT_NAME/" -ErrorAction SilentlyContinue
        Copy-Item "LICENSE*" -Destination "package/$ARTIFACT_NAME/" -ErrorAction SilentlyContinue

        # Create OpenSSL DLLs directory for runtime use
        New-Item -ItemType Directory -Force -Path "package/$ARTIFACT_NAME/bin/openssl"

        # Create empty directory for OpenSSL ARM64 DLLs
        # DLLs will be provided separately from our custom ARM64 OpenSSL build workflow
        Write-Host "Creating empty directory for OpenSSL ARM64 DLLs"

        # Create zip archive
        Compress-Archive -Path "package/$ARTIFACT_NAME" -DestinationPath "package/$ARTIFACT_NAME.zip"

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: echeck-windows-arm64-${{ matrix.link-type == 'Runtime' && 'runtime' || 'static' }}
        path: package/*.zip

  release-artifacts:
    name: Upload artifacts to release
    runs-on: ubuntu-latest
    if: github.event_name == 'release'
    needs: [build-ubuntu, build-macos, build-windows, build-windows-arm64]
    
    steps:
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts
        
    - name: Upload artifacts to release
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const path = require('path');
          const { repo } = context;
          
          // Get the release ID
          const release = context.payload.release;
          
          // Iterate through all downloaded artifacts
          const artifactsDir = 'artifacts';
          const artifacts = fs.readdirSync(artifactsDir);
          
          for (const artifact of artifacts) {
            const artifactDir = path.join(artifactsDir, artifact);
            const files = fs.readdirSync(artifactDir);
            
            for (const file of files) {
              const filePath = path.join(artifactDir, file);
              console.log(`Uploading ${filePath} to release ${release.id}`);
              
              const fileContent = fs.readFileSync(filePath);
              
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.id,
                name: file,
                data: fileContent
              });
            }
          }